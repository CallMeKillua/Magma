import { IndexError, Array} from com.meti;
import com.meti.Allocator as new;

export default struct String {
    + : I8 => String ? IndexError;
    + : String => String ? IndexError;

    length : Size;

    apply : Size => I8 ? IndexError;

    isBlank : () => Bool;

    out unwrap : () => Array;
}

export class def CharsString(values : Array[I8]) >> String => {
    const length = values.length;
    const apply = values.apply;
    const unwrap = values;

    def +(other : I8) => {
        const length = values.length;
        const copy = new[I8](length + 2);

        Streams.Size(0, length)
            .forEach(index => copy(index) = values(index));

        copy(length, other)(length, '\0');

        return CharsString(length + 1, copy);
    }

    def +(other : String) => {
        const length = values.length;
        const copy = new I8[length + other.length + 1];

        Streams.Size(0, length).forEach(index => copy(index) = values(index));
        Streams.Size(0, other.length).forEach(index => copy(length + index) = other(index));

        copy(length + other.length, '\0');

        return CharsString(length + other.length, copy);
    }

    def isBlank() => values.allMatch(Chars.isWhitespace);
}

export def CharString(value : I8) >> String {
    const length = 1;

    def apply(index : Size) => index == 0
         ? value
         : throw IndexError(index);

    def +(other : I8) => CharsString(
        new[I8](2)
        (0, value)
        (1, other));

    def +(other : String) => other + value;

    def isBlank() => Chars.isWhitespace(value);

    def unwrap() => new[I8]
        (0, value)
        (1, '\0');
}

export const Empty = [String]{
    length : 0;
    apply : index => throw IndexError(index);
    isBlank : true;
    unwrap : new[I8](1)(0, '\0');

    +: (value : I8) => CharString(value);
    +: (value : String) => value;
};