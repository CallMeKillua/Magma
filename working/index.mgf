import native "windows";

/*
Native Windows definitions. Don't touch these, unless you know what you're doing!
*/
type LPCSTR = Ref[U16];
type DWORD = U32;

// https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
native const INVALID_FILE_ATTRIBUTES : DWORD;
native def GetFileAttributesW(fileName : LPCSTR) : DWORD;

/**
Define all the operators used by integers and floats. In most languages, these operators are hard-coded into the
compiler, however since this language gives the user the ability to define their own operators, we can do the same here,
even though they're native operators.

We use the `partial` keyword to indicate that we're fulfilling an external definition. Normally, this keyword would be
used when a member is defined in one area and implemented in another. However here, the keyword indicates that it's
fulfilling a need required by the compiler. The compiler will actually look for a structure called `Number` and no Magma
program will be valid if this structure is missing.

We use the `native` keyword because it's built into the compiler itself, and not defined in the source code. This is an
edge case of the `native` keyword, and is really an indicator of, "Don't touch this!", but the `native` keyword is
normally used when interacting with code outside the source code written, e.g. Windows native code, browser JS, or
NodeJS.
*/
partial native struct Number {
  // less than
  native operator def <(other : ThisType) : Bool;

  /**
  Tests whether the value represented by this `Number` is the same as the one represented by the value in the `other`
  parameter. Do note that this method evaluates equality through values. If a comparison of memory locations is
  required, then use the `*` operator and use then use this method to equate the locations.
  */
  native operator def ==(other : ThisType) : Bool;

  /**
  The additive operator. Overflow currently has undefined behavior.
  */
  native operator def +(other : ThisType) : ThisType;
}

/**
Wrapper object for a value that may or may not be present. Other languages may allow the use of `| undefined`, `null`,
or simply a null pointer, but this is the most memory safe and explicit.
*/
interface Option[T]{
    /**
    Maps the value of this option, if present, to a different value. Any exception thrown by the mapper is propagated.
    */
    operator def ->[R, E](mapper : T => R ? E) => Option[R] ? E;

    /**
    Returns the internal value if present or an alternative.
    */
    operator def ??(other : T) => T;
}

/**
Represents an `Option` in which the internal value is guaranteed to exist.
*/
class def Some[T](value : T) << Option[T] {
    def ->(mapper) => Some(mapper(value));
    def ?? => value;
}

/**
Represents an `Option` in which there is no internal value.
*/
object def None[T] << Option[T] {
    -> ==> this;
    ?? = other => this;
}

/**
Represents an error that may occur during any stream operation. Because any error may occur when a stream is running,
the type of the cause cannot be determined at compile time and may have to be casted as a result.
*/
struct StreamError = {
    cause : Option[Ref[Any]] = None;
}

/**
Represents an error that indicates that a stream has ended.
*/
struct EndOfStreamError < StreamError;

/**
Represents a linear process that is invoked upon items of type **T**. It is permissible for a `Stream` to be ran in a
sequential or parallel manner for the benefits of performance, which should not alter the external usage of the Stream.
*/
interface Stream[T] {
    /**
    Returns the head of this stream.
    @throws EndOfStreamError If this stream ended.
    @throws StreamError      If this stream could not compute its head.
    */
    head :=> T ? StreamError;
    /**
    Filters this stream by a predicate. Any error thrown by the predicate is wrapped by a generic `StreamError`.
    */
    filter : [E](predicate : T => Bool ? E) => implements Stream[T] {
        head = () => try {
            let current : T;
            do current = head();
            while(!predicate(current));
            return current;
        } catch(e : StreamError) throw e;
        } catch(e : E) throw StreamError(~e);
    }
    /**
    Returns the first element of this stream. Identical to `head`, with the only difference being if `head` threw an
    `EndOfStreamError`, an `Option` is returned instead.
    */
    first ==>
        try Some(head());
        catch(e : EndOfStreamError) None();
}

/**
Represents a stream of numbers that has an inclusive origin and exclusive terminus.
The internal counter is incremented by `1`.
*/
class def RangeStream[T < Number](start : T, end : T) => {
    let counter = start;

    implements Stream[T] {
        head = () =>
            if(counter < end) counter = counter + 1;
            else throw EndOfStreamError("End of range has been reached.");
    }
}

/**
Represents a sequence of characters. These characters may or may not be Unicode.
*/
interface String {
    /**
    The length of the string.
    */
    length : AnySize;

    /**
    Searches for the last index of a character, or `None` if the character couldn't be found.
    */
    lastChar : I8 => Option[AnySize];

    /**
    Slices this string between an inclusive origin and exclusive terminus. The origin must be equal to or
    */
    slice : (AnySize, AnySize) => String;
}

/**
Thrown if no more bits could be allocated by the **new** operator.
*/
partial native struct OutOfMemoryError {
    bits : AnySize;
}

import native "string";
native def strlen(array : Ref[I8]) : AnySize;

/**
Creates a `String` from a null-terminated sequence of characters.
*/
out class def StringConstructor(array : Ref[I8]) << String => {
    const length = strlen(array);
    def lastChar(value) =>
        try RangeStream(0, length)
            .filter(array[it] == value)
            .first();
        catch(e : StreamError) None();
    def slice(start : AnySize, end : AnySize) => {
        try {
            const array = new U8(end - start);
            RangeStream(start, end)
                .map(array[it]))
                .forEachSequentially(value, index) => array[index = value]);
            return StringConstructor(array);
        } catch(e : StreamError) new "";
    }
}

struct IOException {
}

/**
Represents a Path that points to a file in the file system.
*/
interface Path {
    exists :=> Bool;
    extendWith : String => Path;
    readAsString :=> String ? IOException;
    writeAsString : String => Void ? IOException;
}

/*
Implements Path for Windows machines.
*/
class def WindowsPath(source : String) => {
    def exists() => GetFileAttributes(source) != INVALID_FILE_ATTRIBUTES;

    def extendWith(extension : String) => {
        const fileName = source.lastChar('\\')
            -> source.slice(it)
            ?? source;

        const fileNameWithoutExtension = fileName.firstChar('.')
            -> fileName.slice(0, it)
            ?? fileName;

        return WindowsPath(fileNameWithoutExtension + ".c");
    }
}

struct ApplicationException {
}

struct Application {
    run : () => Void ? ApplicationException;
}

partial const ApplicationImpl : Application;

def main() : I16 => {
    try {
        const path = WindowsPath(".\\index.mgf");
        const application = Application(path);
        application.run();
        return 0;
    } catch(e : ApplicationException) {
        // TODO: do something with the exception here
    }
}