import native "windows";

type LPCSTR = Ref[U16];
type DWORD = U32;

// https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
native const INVALID_FILE_ATTRIBUTES : DWORD;
native def GetFileAttributesW(fileName : LPCSTR) : DWORD;

struct Option[T]{
    -> [R](mapper : T => R) => Option[R];
    ?? (other : T) => T;
}

partial struct Number {
  native operator < =(other : ThisType) : Bool;
  native operator == =(other : ThisType) : Bool;

  native operator + =(other : ThisType) : ThisType;
}

struct StreamException = {
    cause : Option[Ref[Any]] = None;
}

struct EndOfStreamException < StreamException;

interface Stream[T] {
    head :=> T ? StreamException;
    filter : [E](predicate : T => Bool ? E) => implements Stream[T] {
        head = () => try {
            let current : T;
            do current = head();
            while(!predicate(current));
            return current;
        } catch(e : StreamException) throw e;
        } catch(e : E) throw StreamException(~e);
    }
    first ==>
        try Some(head());
        catch(e : EndOfStreamException) None();
}

class def RangeStream[T < Number](start : T, end : T) => {
    let counter = start;

    implements Stream[T] {
        head = () =>
            if(counter < end) counter = counter + 1;
            else throw EndOfStreamException("End of range has been reached.");
    }
}

struct String {
    length : AnySize;
    lastChar : U8 => Option[AnySize];
    slice : (AnySize, AnySize) => String;
}

partial native struct OutOfMemoryException {
    bits : AnySize;
}

// null-terminated
out def StringConstructor(array : Ref[U8]) : String => {
    return {
        length = array[length];
        lastChar = value =>
            try RangeStream(0, length)
                .filter(array[it] == value)
                .first();
            catch(e : StreamException) None();
        slice = (start : AnySize, end : AnySize) => {
            try {
                const array = new U8(end - start);
                RangeStream(start, end)
                    .map(array[it]))
                    .forEachSequentially(value, index) => array[index = value]);
                return StringConstructor(array);
            } catch(e : StreamException) new "";
        }
    }
}

class def WindowsPath(source : String) => {
    def exists() => GetFileAttributes(source) != INVALID_FILE_ATTRIBUTES;

    def extendWith(extension : String) => {
        const fileName = source.lastChar('\\')
            -> source.slice(it)
            ?? source;

        const fileNameWithoutExtension = fileName.firstChar('.')
            -> fileName.slice(0, it)
            ?? fileName;

        return WindowsPath(fileNameWithoutExtension + ".c");
    }
}

def main() : I16 => {
    return 0;
}